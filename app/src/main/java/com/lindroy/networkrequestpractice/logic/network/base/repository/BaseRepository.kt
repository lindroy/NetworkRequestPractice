package com.lindroy.networkrequestpractice.logic.network.base.repositoryimport androidx.lifecycle.LiveDataimport androidx.lifecycle.liveDataimport com.lindroy.networkrequestpractice.logic.model.*import com.lindroy.networkrequestpractice.logic.network.base.RequestExceptionimport com.lindroy.networkrequestpractice.logic.network.base.observer.BaseResponseimport kotlinx.coroutines.Dispatchersimport kotlin.coroutines.CoroutineContext/** * @author Lin * @date 2021/10/15 * @function 唯一数据源 */abstract class BaseRepository {    /**     * 注意：将errorCode不为0时归为Result.failure后getOrNull()的值为null，这样是无法再去获取请求结果的，     * 只能通过拿到exceptionOrNull去拿Exception中的内容     */    private fun <T> parseHttpResult(result: ApiResponse<T>) = if (result.success) {        Result.success(result)    } else {        Result.failure(RequestException(result))    }    protected fun <T> fire(        context: CoroutineContext = Dispatchers.IO,        block: suspend () -> BaseResponse<T>    ): LiveData<BaseResponse<T>> = liveData(context) {        this.runCatching {            block()        }.onSuccess {            //status code为200，继续判断errorCode是否为0            emit(                when (it.success) {                    true -> checkEmptyResponse(it.data)                    false -> ErrorResponse(it.errorCode, it.errorMsg)                }            )        }.onFailure { throwable ->            emit(FailureResponse(throwable))            /*if (throwable is HttpException) {                //获取Status Code不为200时的异常信息                val errorModel = throwable.response()?.errorBody()?.string()?.run {                    Gson().fromJson(this, ErrorBodyModel::class.java)                } ?: ErrorBodyModel()                emit(FailureResponse(throwable.code(), errorModel.message))            } else {                emit(FailureResponse(-1, throwable.message))            }*/        }    }    private fun <T> checkEmptyResponse(data: T?): ApiResponse<T> =        if (data == null || (data is List<*> && (data as List<*>).isEmpty())) {            EmptyResponse()        } else {            SuccessResponse(data)        }}