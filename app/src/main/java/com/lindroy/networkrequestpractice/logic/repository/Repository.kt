package com.lindroy.networkrequestpractice.logic.repositoryimport androidx.lifecycle.LiveDataimport androidx.lifecycle.liveDataimport com.google.gson.Gsonimport com.lindroy.networkrequestpractice.logic.model.*import com.lindroy.networkrequestpractice.logic.network.ApiExceptionimport com.lindroy.networkrequestpractice.logic.network.NetworkDataSourceimport kotlinx.coroutines.Dispatchersimport retrofit2.HttpExceptionimport kotlin.coroutines.CoroutineContext/** * @author Lin * @date 2021/10/15 * @function 唯一数据源 */object Repository {    fun login(pwd: String) = fire {        NetworkDataSource.login(pwd)    }    /**     * 注意：将errorCode不为0时归为Result.failure后getOrNull()的值为null，这样是无法再去获取请求结果的，     * 只能通过拿到exceptionOrNull去拿Exception中的内容     */    private fun <T> parseHttpResult(result: BaseResponse<T>) = if (result.success) {        Result.success(result)    } else {        Result.failure(ApiException(result))    }    private fun <T> fire(        context: CoroutineContext = Dispatchers.IO,        block: suspend () -> BaseResponse<T>    ): LiveData<BaseResponse<T>> = liveData(context) {        this.runCatching {            block()        }.onSuccess {            //status code为200，继续判断errorCode是否为0            if (it.success) {                emit(checkEmptyResponse(it.data))            } else {                emit(ErrorResponse(it.data, it.errorCode, it.errorMsg))            }        }.onFailure { throwable ->            if (throwable is HttpException) {                //获取Status Code不为200时的异常信息                val errorModel = throwable.response()?.errorBody()?.string()?.run {                    Gson().fromJson(this, ErrorBodyModel::class.java)                } ?: ErrorBodyModel()                emit(FailureResponse(throwable.code(), errorModel.message))            } else {                emit(FailureResponse(-1, throwable.message))            }        }    }    private fun <T> checkEmptyResponse(data: T?): BaseResponse<T> =        if (data == null || (data is List<*> && (data as List<*>).isEmpty())) {            EmptyResponse()        } else {            SuccessResponse(data)        }}